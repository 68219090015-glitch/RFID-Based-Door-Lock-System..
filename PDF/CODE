#include <SPI.h>
#include <MFRC522.h>
#include <LiquidCrystal_I2C.h>
#include <Servo.h>

#define SS_PIN 10
#define RST_PIN 9
#define BUZZER_PIN 3
#define SERVO_PIN 5

MFRC522 mfrc522(SS_PIN, RST_PIN);
LiquidCrystal_I2C lcd(0x27, 16, 2);
Servo myServo;

byte keyCardUID[] = {0x04, 0xA1, 0xB2, 0xC3}; 
bool isOpen = false; // ตัวแปรเก็บสถานะ: false = ปิดอยู่, true = เปิดอยู่

void setup() {
  Serial.begin(9600);
  SPI.begin();
  mfrc522.PCD_Init();
  lcd.init();
  lcd.backlight();
  myServo.attach(SERVO_PIN);
  
  myServo.write(0); // เริ่มต้นที่สถานะปิด
  lcd.setCursor(0, 0);
  lcd.print("Door: LOCKED");
  pinMode(BUZZER_PIN, OUTPUT);
}

void loop() {
  if (!mfrc522.PICC_IsNewCardPresent() || !mfrc522.PICC_ReadCardSerial()) {
    return;
  }

  bool isMatch = true;
  for (byte i = 0; i < 4; i++) {
    if (mfrc522.uid.uidByte[i] != keyCardUID[i]) {
      isMatch = false;
      break;
    }
  }

  if (isMatch) {
    isOpen = !isOpen; // สลับสถานะ (ถ้า true เป็น false / ถ้า false เป็น true)
    
    lcd.clear();
    tone(BUZZER_PIN, 2000, 200); // เสียงติ๊ดแจ้งเตือน

    if (isOpen) {
      // --- กรณีสั่งเปิด ---
      myServo.write(90); 
      lcd.setCursor(0, 0);
      lcd.print("PASS: UNLOCKED");
      Serial.println("Door Opened");
    } else {
      // --- กรณีสั่งปิด ---
      myServo.write(0);
      lcd.setCursor(0, 0);
      lcd.print("PASS: LOCKED");
      Serial.println("Door Closed");
    }
    
    delay(2000); // หน่วงเวลาเล็กน้อยเพื่อป้องกันการอ่านซ้ำซ้อน
  } else {
    // กรณีบัตรไม่ถูกต้อง
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("NO PASS");
    tone(BUZZER_PIN, 300, 500);
    delay(1000);
  }

  // แสดงสถานะปัจจุบันค้างไว้บนจอ
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print(isOpen ? "Status: OPEN" : "Status: LOCKED");
  mfrc522.PICC_HaltA();
}
